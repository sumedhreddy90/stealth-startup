{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/Users/sumedhreddy/Documents/stealth/stealth-startup/node_modules/react-native-snap-carousel/index.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component, PropTypes } from 'react';\nimport ScrollView from \"react-native-web/dist/exports/ScrollView\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\n\nvar Carousel = function (_Component) {\n  _inherits(Carousel, _Component);\n\n  var _super = _createSuper(Carousel);\n\n  function Carousel(props) {\n    var _this;\n\n    _classCallCheck(this, Carousel);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      activeItem: props.firstItem\n    };\n    _this._positions = [];\n\n    _this._calcCardPositions(props);\n\n    _this._onScroll = _this._onScroll.bind(_assertThisInitialized(_this));\n    _this._onScrollEndDrag = _this._snapEnabled ? _this._onScrollEndDrag.bind(_assertThisInitialized(_this)) : false;\n    _this._onScrollBegin = _this._snapEnabled ? _this._onScrollBegin.bind(_assertThisInitialized(_this)) : false;\n    _this._initInterpolators = _this._initInterpolators.bind(_assertThisInitialized(_this));\n    _this._onTouchRelease = props.autoplay ? _this._onTouchRelease.bind(_assertThisInitialized(_this)) : undefined;\n    _this._onTouchMove = props.autoplay ? _this._onTouchMove.bind(_assertThisInitialized(_this)) : undefined;\n    return _this;\n  }\n\n  _createClass(Carousel, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          firstItem = _this$props.firstItem,\n          autoplay = _this$props.autoplay;\n\n      this._initInterpolators(this.props);\n\n      setTimeout(function () {\n        _this2.snapToItem(firstItem, false, false);\n      }, 0);\n\n      if (autoplay) {\n        this.startAutoplay();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.stopAutoplay();\n    }\n  }, {\n    key: \"_snapEnabled\",\n    get: function get() {\n      var _this$props2 = this.props,\n          enableSnap = _this$props2.enableSnap,\n          snapOnAndroid = _this$props2.snapOnAndroid;\n      return enableSnap && (Platform.OS === 'ios' || snapOnAndroid);\n    }\n  }, {\n    key: \"_nextItem\",\n    get: function get() {\n      var activeItem = this.state.activeItem;\n      return this._positions[activeItem + 1] ? activeItem + 1 : 0;\n    }\n  }, {\n    key: \"_calcCardPositions\",\n    value: function _calcCardPositions() {\n      var _this3 = this;\n\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var items = props.items,\n          sliderWidth = props.sliderWidth,\n          itemWidth = props.itemWidth;\n      items.forEach(function (item, index) {\n        _this3._positions[index] = {\n          start: index * itemWidth\n        };\n        _this3._positions[index].end = _this3._positions[index].start + itemWidth;\n      });\n    }\n  }, {\n    key: \"_initInterpolators\",\n    value: function _initInterpolators() {\n      var _this$props3 = this.props,\n          items = _this$props3.items,\n          firstItem = _this$props3.firstItem;\n      var interpolators = [];\n      items.forEach(function (item, index) {\n        interpolators.push(new Animated.Value(index === firstItem ? 1 : 0));\n      });\n      this.setState({\n        interpolators: interpolators\n      });\n    }\n  }, {\n    key: \"_getActiveItem\",\n    value: function _getActiveItem(centerX) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 25;\n\n      for (var i = 0; i < this._positions.length; i++) {\n        var _this$_positions$i = this._positions[i],\n            start = _this$_positions$i.start,\n            end = _this$_positions$i.end;\n\n        if (centerX + offset >= start && centerX - offset <= end) {\n          return i;\n        }\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"_getCenterX\",\n    value: function _getCenterX(event) {\n      var _this$props4 = this.props,\n          sliderWidth = _this$props4.sliderWidth,\n          itemWidth = _this$props4.itemWidth;\n      var containerSideMargin = (sliderWidth - itemWidth) / 2;\n      return event.nativeEvent.contentOffset.x + sliderWidth / 2 - containerSideMargin;\n    }\n  }, {\n    key: \"_onScroll\",\n    value: function _onScroll(event) {\n      var _this$props5 = this.props,\n          animationFunc = _this$props5.animationFunc,\n          animationOptions = _this$props5.animationOptions;\n      var activeItem = this.state.activeItem;\n\n      var newActiveItem = this._getActiveItem(this._getCenterX(event));\n\n      if (activeItem !== newActiveItem) {\n        Animated[animationFunc](this.state.interpolators[activeItem], _objectSpread(_objectSpread({}, animationOptions), {}, {\n          toValue: 0\n        })).start();\n        this.setState({\n          activeItem: newActiveItem\n        });\n        Animated[animationFunc](this.state.interpolators[newActiveItem], _objectSpread(_objectSpread({}, animationOptions), {}, {\n          toValue: 1\n        })).start();\n      }\n    }\n  }, {\n    key: \"_onScrollBegin\",\n    value: function _onScrollBegin(event) {\n      this._scrollStartX = event.nativeEvent.contentOffset.x;\n      this._scrollStartActive = this.state.activeItem;\n    }\n  }, {\n    key: \"_onScrollEndDrag\",\n    value: function _onScrollEndDrag(event) {\n      this._scrollEndX = event.nativeEvent.contentOffset.x;\n      this._scrollEndActive = this.state.activeItem;\n      var deltaX = this._scrollEndX - this._scrollStartX;\n\n      if (this._snapEnabled) {\n        this._snapScroll(deltaX);\n      }\n    }\n  }, {\n    key: \"_onTouchMove\",\n    value: function _onTouchMove() {\n      if (this._autoplaying) {\n        this.stopAutoplay();\n      }\n\n      clearTimeout(this._enableAutoplayTimeout);\n    }\n  }, {\n    key: \"_onTouchRelease\",\n    value: function _onTouchRelease() {\n      var _this4 = this;\n\n      var autoplayDelay = this.props.autoplayDelay;\n      setTimeout(function () {\n        _this4._enableAutoplayTimeout = setTimeout(function () {\n          _this4.startAutoplay(true);\n        }, autoplayDelay);\n      }, 1000);\n    }\n  }, {\n    key: \"_snapScroll\",\n    value: function _snapScroll(deltaX) {\n      var swipeThreshold = this.props.swipeThreshold;\n\n      if (this._scrollStartActive !== this._scrollEndActive) {\n        this.snapToItem(this._scrollEndActive);\n      } else {\n        if (deltaX > 0) {\n          if (deltaX > swipeThreshold) {\n            this.snapToItem(this._scrollStartActive + 1);\n          } else {\n            this.snapToItem(this._scrollEndActive);\n          }\n        } else if (deltaX < 0) {\n          if (deltaX < -swipeThreshold) {\n            this.snapToItem(this._scrollStartActive - 1);\n          } else {\n            this.snapToItem(this._scrollEndActive);\n          }\n        } else {\n          this.snapToItem(this._scrollEndActive);\n        }\n      }\n    }\n  }, {\n    key: \"items\",\n    get: function get() {\n      var _this5 = this;\n\n      var _this$props6 = this.props,\n          items = _this$props6.items,\n          renderItem = _this$props6.renderItem,\n          slideStyle = _this$props6.slideStyle,\n          inactiveSlideScale = _this$props6.inactiveSlideScale,\n          inactiveSlideOpacity = _this$props6.inactiveSlideOpacity;\n\n      if (!this.state.interpolators || !this.state.interpolators.length) {\n        return false;\n      }\n\n      return items.map(function (entry, index) {\n        var animatedValue = _this5.state.interpolators[index];\n        return React.createElement(Animated.View, {\n          key: \"carousel-item-\" + index,\n          style: [slideStyle, {\n            transform: [{\n              scale: animatedValue.interpolate({\n                inputRange: [0, 1],\n                outputRange: [inactiveSlideScale, 1]\n              })\n            }],\n            opacity: animatedValue.interpolate({\n              inputRange: [0, 1],\n              outputRange: [inactiveSlideOpacity, 1]\n            })\n          }],\n          __self: _this5,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 281,\n            columnNumber: 17\n          }\n        }, renderItem(entry, index));\n      });\n    }\n  }, {\n    key: \"startAutoplay\",\n    value: function startAutoplay() {\n      var _this6 = this;\n\n      var instantly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var _this$props7 = this.props,\n          autoplayInterval = _this$props7.autoplayInterval,\n          autoplayDelay = _this$props7.autoplayDelay;\n\n      if (this._autoplaying) {\n        return;\n      }\n\n      setTimeout(function () {\n        _this6._autoplaying = true;\n        _this6._autoplayInterval = setInterval(function () {\n          _this6.snapToItem(_this6._nextItem);\n        }, autoplayInterval);\n      }, instantly ? 0 : autoplayDelay);\n    }\n  }, {\n    key: \"stopAutoplay\",\n    value: function stopAutoplay() {\n      this._autoplaying = false;\n      clearInterval(this._autoplayInterval);\n    }\n  }, {\n    key: \"snapToItem\",\n    value: function snapToItem(index) {\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var fireCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var itemsLength = this._positions.length;\n\n      if (index >= itemsLength) {\n        index = itemsLength - 1;\n        fireCallback = false;\n      } else if (index < 0) {\n        index = 0;\n        fireCallback = false;\n      }\n\n      var snapX = this._positions[index].start;\n\n      if (this.refs.scrollview) {\n        this.refs.scrollview.scrollTo({\n          x: snapX,\n          y: 0,\n          animated: animated\n        });\n        this.props.onSnapToItem && fireCallback && this.props.onSnapToItem(index, this.props.items[index]);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props8 = this.props,\n          sliderWidth = _this$props8.sliderWidth,\n          itemWidth = _this$props8.itemWidth,\n          containerCustomStyle = _this$props8.containerCustomStyle,\n          contentContainerCustomStyle = _this$props8.contentContainerCustomStyle;\n      var containerSideMargin = (sliderWidth - itemWidth) / 2;\n      var style = [{\n        paddingHorizontal: Platform.OS === 'ios' ? containerSideMargin : 0\n      }, containerCustomStyle || {}];\n      var contentContainerStyle = [{\n        paddingHorizontal: Platform.OS === 'android' ? containerSideMargin : 0\n      }, contentContainerCustomStyle || {}];\n      return React.createElement(ScrollView, _extends({}, this.props, {\n        style: style,\n        contentContainerStyle: contentContainerStyle,\n        ref: 'scrollview',\n        horizontal: true,\n        onScrollBeginDrag: this._onScrollBegin,\n        onScrollEndDrag: this._onScrollEndDrag,\n        onResponderRelease: this._onTouchRelease,\n        onResponderMove: this._onTouchMove,\n        onScroll: this._onScroll,\n        scrollEventThrottle: 50,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 359,\n          columnNumber: 13\n        }\n      }), this.items);\n    }\n  }]);\n\n  return Carousel;\n}(Component);\n\nCarousel.propTypes = _objectSpread(_objectSpread({}, ScrollView.propTypes), {}, {\n  items: PropTypes.array.isRequired,\n  sliderWidth: PropTypes.number.isRequired,\n  itemWidth: PropTypes.number.isRequired,\n  renderItem: PropTypes.func.isRequired,\n  slideStyle: PropTypes.number.isRequired,\n  containerCustomStyle: PropTypes.number,\n  contentContainerCustomStyle: PropTypes.number,\n  swipeThreshold: PropTypes.number,\n  animationFunc: PropTypes.string,\n  animationOptions: PropTypes.object,\n  inactiveSlideScale: PropTypes.number,\n  inactiveSlideOpacity: PropTypes.number,\n  firstItem: PropTypes.number,\n  autoplay: PropTypes.bool,\n  autoplayInterval: PropTypes.number,\n  autoplayDelay: PropTypes.number,\n  enableSnap: PropTypes.bool,\n  snapOnAndroid: PropTypes.bool,\n  onSnapToItem: PropTypes.func\n});\nCarousel.defaultProps = {\n  autoplay: false,\n  autoplayInterval: 3000,\n  autoplayDelay: 5000,\n  firstItem: 0,\n  enableSnap: true,\n  snapOnAndroid: false,\n  swipeThreshold: 20,\n  animationFunc: 'timing',\n  animationOptions: {\n    easing: Easing.elastic(1)\n  },\n  slideStyle: {},\n  containerCustomStyle: null,\n  contentContainerCustomStyle: null,\n  inactiveSlideScale: 0.9,\n  inactiveSlideOpacity: 1\n};\nexport { Carousel as default };","map":{"version":3,"sources":["/Users/sumedhreddy/Documents/stealth/stealth-startup/node_modules/react-native-snap-carousel/index.js"],"names":["React","Component","PropTypes","Carousel","props","state","activeItem","firstItem","_positions","_calcCardPositions","_onScroll","bind","_onScrollEndDrag","_snapEnabled","_onScrollBegin","_initInterpolators","_onTouchRelease","autoplay","undefined","_onTouchMove","setTimeout","snapToItem","startAutoplay","stopAutoplay","enableSnap","snapOnAndroid","Platform","OS","items","sliderWidth","itemWidth","forEach","item","index","start","end","interpolators","push","Animated","Value","setState","centerX","offset","i","length","event","containerSideMargin","nativeEvent","contentOffset","x","animationFunc","animationOptions","newActiveItem","_getActiveItem","_getCenterX","toValue","_scrollStartX","_scrollStartActive","_scrollEndX","_scrollEndActive","deltaX","_snapScroll","_autoplaying","clearTimeout","_enableAutoplayTimeout","autoplayDelay","swipeThreshold","renderItem","slideStyle","inactiveSlideScale","inactiveSlideOpacity","map","entry","animatedValue","transform","scale","interpolate","inputRange","outputRange","opacity","instantly","autoplayInterval","_autoplayInterval","setInterval","_nextItem","clearInterval","animated","fireCallback","itemsLength","snapX","refs","scrollview","scrollTo","y","onSnapToItem","containerCustomStyle","contentContainerCustomStyle","style","paddingHorizontal","contentContainerStyle","propTypes","ScrollView","array","isRequired","number","func","string","object","bool","defaultProps","easing","Easing","elastic"],"mappings":"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","sourcesContent":["import React, { Component, PropTypes } from 'react';\nimport { ScrollView, Animated, Platform, Easing } from 'react-native';\n\nexport default class Carousel extends Component {\n\n    static propTypes = {\n        ...ScrollView.propTypes,\n        /**\n         * Supply items to loop on\n         */\n        items: PropTypes.array.isRequired,\n        /**\n         * Width in pixels of your slider according\n         * to your styles\n         */\n        sliderWidth: PropTypes.number.isRequired,\n        /**\n         * Width in pixels of your elements\n         */\n        itemWidth: PropTypes.number.isRequired,\n        /**\n         * Function returning a react element. The entry\n         * data is the 1st parameter, its index is the 2nd\n         */\n        renderItem: PropTypes.func.isRequired,\n        /**\n         * Style of each item's container\n         */\n        slideStyle: PropTypes.number.isRequired,\n        /**\n        * Global wrapper's style\n        */\n        containerCustomStyle: PropTypes.number,\n        /**\n        * Content container's style\n        */\n        contentContainerCustomStyle: PropTypes.number,\n        /**\n         * Delta x when swiping to trigger the snap\n         */\n        swipeThreshold: PropTypes.number,\n        /**\n         * Animated animation to use. Provide the name\n         * of the method, defaults to timing\n         */\n        animationFunc: PropTypes.string,\n        /**\n         * Animation options to be merged with the\n         * default ones. Can be used w/ animationFunc\n         */\n        animationOptions: PropTypes.object,\n        /**\n         * Scale factor of the inactive slides\n         */\n        inactiveSlideScale: PropTypes.number,\n        /**\n         * Opacity value of the inactive slides\n         */\n        inactiveSlideOpacity: PropTypes.number,\n        /**\n         * Index of the first item to display\n         */\n        firstItem: PropTypes.number,\n        /**\n         * Trigger autoplay\n         */\n        autoplay: PropTypes.bool,\n        /**\n         * Delay until navigating to the next item\n         */\n        autoplayInterval: PropTypes.number,\n        /**\n         * Delay before enabling autoplay on startup and\n         * after releasing the touch\n         */\n        autoplayDelay: PropTypes.number,\n        /**\n         * If enabled, releasing the touch will scroll\n         * to the center of the nearest/active item\n         */\n        enableSnap: PropTypes.bool,\n        /**\n         * Snapping on android is kinda choppy, especially\n         * when swiping quickly so you can disable it\n         */\n        snapOnAndroid: PropTypes.bool,\n        /**\n         * Fired when snapping to an item\n         */\n        onSnapToItem: PropTypes.func\n    };\n\n    static defaultProps = {\n        autoplay: false,\n        autoplayInterval: 3000,\n        autoplayDelay: 5000,\n        firstItem: 0,\n        enableSnap: true,\n        snapOnAndroid: false,\n        swipeThreshold: 20,\n        animationFunc: 'timing',\n        animationOptions: {\n            easing: Easing.elastic(1)\n        },\n        slideStyle: {},\n        containerCustomStyle: null,\n        contentContainerCustomStyle: null,\n        inactiveSlideScale: 0.9,\n        inactiveSlideOpacity: 1\n    }\n\n    constructor (props) {\n        super(props);\n        this.state = {\n            activeItem: props.firstItem\n        };\n        this._positions = [];\n        this._calcCardPositions(props);\n        this._onScroll = this._onScroll.bind(this);\n        this._onScrollEndDrag = this._snapEnabled ? this._onScrollEndDrag.bind(this) : false;\n        this._onScrollBegin = this._snapEnabled ? this._onScrollBegin.bind(this) : false;\n        this._initInterpolators = this._initInterpolators.bind(this);\n        this._onTouchRelease = props.autoplay ? this._onTouchRelease.bind(this) : undefined;\n        this._onTouchMove = props.autoplay ? this._onTouchMove.bind(this) : undefined;\n    }\n\n    componentDidMount () {\n        const { firstItem, autoplay } = this.props;\n\n        this._initInterpolators(this.props);\n        setTimeout(() => {\n            this.snapToItem(firstItem, false, false);\n        }, 0);\n        if (autoplay) {\n            this.startAutoplay();\n        }\n    }\n\n    componentWillUnmount () {\n        this.stopAutoplay();\n    }\n\n    get _snapEnabled () {\n        const { enableSnap, snapOnAndroid } = this.props;\n\n        return enableSnap && (Platform.OS === 'ios' || snapOnAndroid);\n    }\n\n    get _nextItem () {\n        const { activeItem } = this.state;\n\n        return this._positions[activeItem + 1] ? activeItem + 1 : 0;\n    }\n\n    _calcCardPositions (props = this.props) {\n        const { items, sliderWidth, itemWidth } = props;\n\n        items.forEach((item, index) => {\n            this._positions[index] = {\n                start: index * itemWidth\n            };\n            this._positions[index].end = this._positions[index].start + itemWidth;\n        });\n    }\n\n    _initInterpolators () {\n        const { items, firstItem } = this.props;\n        let interpolators = [];\n\n        items.forEach((item, index) => {\n            interpolators.push(new Animated.Value(index === firstItem ? 1 : 0));\n        });\n        this.setState({ interpolators });\n    }\n\n    _getActiveItem (centerX, offset = 25) {\n        for (let i = 0; i < this._positions.length; i++) {\n            const { start, end } = this._positions[i];\n            if (centerX + offset >= start && centerX - offset <= end) {\n                return i;\n            }\n        }\n        return 0;\n    }\n\n    _getCenterX (event) {\n        const { sliderWidth, itemWidth } = this.props;\n        const containerSideMargin = (sliderWidth - itemWidth) / 2;\n\n        return event.nativeEvent.contentOffset.x + sliderWidth / 2 - containerSideMargin;\n    }\n\n    _onScroll (event) {\n        const { animationFunc, animationOptions } = this.props;\n        const { activeItem } = this.state;\n        const newActiveItem = this._getActiveItem(this._getCenterX(event));\n\n        if (activeItem !== newActiveItem) {\n            Animated[animationFunc](\n                this.state.interpolators[activeItem],\n                { ...animationOptions, toValue: 0 }\n            ).start();\n            this.setState({ activeItem: newActiveItem });\n            Animated[animationFunc](\n                this.state.interpolators[newActiveItem],\n                { ...animationOptions, toValue: 1 }\n            ).start();\n        }\n    }\n\n    _onScrollBegin (event) {\n        this._scrollStartX = event.nativeEvent.contentOffset.x;\n        this._scrollStartActive = this.state.activeItem;\n    }\n\n    _onScrollEndDrag (event) {\n        this._scrollEndX = event.nativeEvent.contentOffset.x;\n        this._scrollEndActive = this.state.activeItem;\n\n        const deltaX = this._scrollEndX - this._scrollStartX;\n\n        if (this._snapEnabled) {\n            this._snapScroll(deltaX);\n        }\n    }\n\n    _onTouchMove () {\n        if (this._autoplaying) {\n            this.stopAutoplay();\n        }\n        clearTimeout(this._enableAutoplayTimeout);\n    }\n\n    _onTouchRelease () {\n        const { autoplayDelay } = this.props;\n\n        setTimeout(() => {\n            this._enableAutoplayTimeout =\n                setTimeout(() => {\n                    this.startAutoplay(true);\n                }, autoplayDelay);\n        }, 1000);\n    }\n\n    _snapScroll (deltaX) {\n        const { swipeThreshold } = this.props;\n\n        if (this._scrollStartActive !== this._scrollEndActive) {\n            // Snap to the new active item\n            this.snapToItem(this._scrollEndActive);\n        } else {\n            // Snap depending on delta\n            if (deltaX > 0) {\n                if (deltaX > swipeThreshold) {\n                    this.snapToItem(this._scrollStartActive + 1);\n                } else {\n                    this.snapToItem(this._scrollEndActive);\n                }\n            } else if (deltaX < 0) {\n                if (deltaX < -swipeThreshold) {\n                    this.snapToItem(this._scrollStartActive - 1);\n                } else {\n                    this.snapToItem(this._scrollEndActive);\n                }\n            } else {\n                // Snap to current\n                this.snapToItem(this._scrollEndActive);\n            }\n        }\n    }\n\n    get items () {\n        const { items, renderItem, slideStyle, inactiveSlideScale, inactiveSlideOpacity } = this.props;\n        if (!this.state.interpolators || !this.state.interpolators.length) {\n            return false;\n        }\n\n        return items.map((entry, index) => {\n            const animatedValue = this.state.interpolators[index];\n            return (\n                <Animated.View\n                  key={`carousel-item-${index}`}\n                  style={[\n                      slideStyle,\n                      {transform: [{\n                          scale: animatedValue.interpolate({\n                              inputRange: [0, 1],\n                              outputRange: [inactiveSlideScale, 1]\n                          })\n                      }],\n                    opacity: animatedValue.interpolate({\n                        inputRange: [0, 1],\n                        outputRange: [inactiveSlideOpacity, 1]\n                    })\n                    }\n                  ]}>\n                    { renderItem(entry, index) }\n                </Animated.View>\n            );\n        });\n    }\n\n    startAutoplay (instantly = false) {\n        const { autoplayInterval, autoplayDelay } = this.props;\n\n        if (this._autoplaying) {\n            return;\n        }\n\n        setTimeout(() => {\n            this._autoplaying = true;\n            this._autoplayInterval =\n                setInterval(() => {\n                    this.snapToItem(this._nextItem);\n                }, autoplayInterval);\n        }, instantly ? 0 : autoplayDelay);\n    }\n\n    stopAutoplay () {\n        this._autoplaying = false;\n        clearInterval(this._autoplayInterval);\n    }\n\n    snapToItem (index, animated = true, fireCallback = true) {\n        const itemsLength = this._positions.length;\n\n        if (index >= itemsLength) {\n            index = itemsLength - 1;\n            fireCallback = false;\n        } else if (index < 0) {\n            index = 0;\n            fireCallback = false;\n        }\n\n        const snapX = this._positions[index].start;\n\n        // Make sure the component hasn't been unmounted\n        if (this.refs.scrollview) {\n            this.refs.scrollview.scrollTo({x: snapX, y: 0, animated});\n            this.props.onSnapToItem && fireCallback && this.props.onSnapToItem(index, this.props.items[index]);\n        }\n\n    }\n\n    render () {\n        const { sliderWidth, itemWidth, containerCustomStyle, contentContainerCustomStyle } = this.props;\n\n        const containerSideMargin = (sliderWidth - itemWidth) / 2;\n        const style = [\n            { paddingHorizontal: Platform.OS === 'ios' ? containerSideMargin : 0 },\n            containerCustomStyle || {}\n        ];\n        const contentContainerStyle = [\n            { paddingHorizontal: Platform.OS === 'android' ? containerSideMargin : 0 },\n            contentContainerCustomStyle || {}\n        ];\n\n        return (\n            <ScrollView\n              {...this.props}\n              style={style}\n              contentContainerStyle={contentContainerStyle}\n              ref={'scrollview'}\n              horizontal={true}\n              onScrollBeginDrag={this._onScrollBegin}\n              onScrollEndDrag={this._onScrollEndDrag}\n              onResponderRelease={this._onTouchRelease}\n              onResponderMove={this._onTouchMove}\n              onScroll={this._onScroll}\n              scrollEventThrottle={50}\n              >\n                { this.items }\n            </ScrollView>\n        );\n    }\n}\n"]},"metadata":{},"sourceType":"module"}