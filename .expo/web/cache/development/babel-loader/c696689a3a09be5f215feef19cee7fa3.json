{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/Users/sumedhreddy/Documents/stealth/stealth-startup/node_modules/react-native-snap-carousel/index.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component, PropTypes } from 'react';\nimport ScrollView from \"react-native-web/dist/exports/ScrollView\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport shallowCompare from 'react-addons-shallow-compare';\n\nvar Carousel = function (_Component) {\n  _inherits(Carousel, _Component);\n\n  var _super = _createSuper(Carousel);\n\n  function Carousel(props) {\n    var _this;\n\n    _classCallCheck(this, Carousel);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      activeItem: props.firstItem\n    };\n    _this._positions = [];\n\n    _this._calcCardPositions(props);\n\n    _this._onTouchStart = _this._onTouchStart.bind(_assertThisInitialized(_this));\n    _this._onScroll = _this._onScroll.bind(_assertThisInitialized(_this));\n    _this._onScrollEnd = _this._snapEnabled ? _this._onScrollEnd.bind(_assertThisInitialized(_this)) : false;\n    _this._onScrollBegin = _this._snapEnabled ? _this._onScrollBegin.bind(_assertThisInitialized(_this)) : false;\n    _this._initInterpolators = _this._initInterpolators.bind(_assertThisInitialized(_this));\n    _this._onTouchRelease = _this._onTouchRelease.bind(_assertThisInitialized(_this));\n    _this._ignoreNextMomentum = false;\n    return _this;\n  }\n\n  _createClass(Carousel, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          firstItem = _this$props.firstItem,\n          autoplay = _this$props.autoplay;\n\n      this._initInterpolators(this.props);\n\n      setTimeout(function () {\n        _this2.snapToItem(firstItem, false, false, true);\n      }, 0);\n\n      if (autoplay) {\n        this.startAutoplay();\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      if (this.props.shouldOptimizeUpdates === false) {\n        return true;\n      } else {\n        return shallowCompare(this, nextProps, nextState);\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      var items = nextProps.items,\n          firstItem = nextProps.firstItem;\n\n      if (items.length !== this.props.items.length) {\n        this._positions = [];\n\n        this._calcCardPositions(nextProps);\n\n        this._initInterpolators(nextProps);\n\n        this.setState({\n          activeItem: firstItem\n        });\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.stopAutoplay();\n    }\n  }, {\n    key: \"_snapEnabled\",\n    get: function get() {\n      var _this$props2 = this.props,\n          enableSnap = _this$props2.enableSnap,\n          snapOnAndroid = _this$props2.snapOnAndroid;\n      return enableSnap && (Platform.OS === 'ios' || snapOnAndroid);\n    }\n  }, {\n    key: \"_nextItem\",\n    get: function get() {\n      var activeItem = this.state.activeItem;\n      return this._positions[activeItem + 1] ? activeItem + 1 : 0;\n    }\n  }, {\n    key: \"_calcCardPositions\",\n    value: function _calcCardPositions() {\n      var _this3 = this;\n\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var items = props.items,\n          itemWidth = props.itemWidth;\n      items.forEach(function (item, index) {\n        _this3._positions[index] = {\n          start: index * itemWidth\n        };\n        _this3._positions[index].end = _this3._positions[index].start + itemWidth;\n      });\n    }\n  }, {\n    key: \"_initInterpolators\",\n    value: function _initInterpolators() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var items = props.items,\n          firstItem = props.firstItem;\n      var interpolators = [];\n      items.forEach(function (item, index) {\n        interpolators.push(new Animated.Value(index === firstItem ? 1 : 0));\n      });\n      this.setState({\n        interpolators: interpolators\n      });\n    }\n  }, {\n    key: \"_getActiveItem\",\n    value: function _getActiveItem(centerX) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 25;\n\n      for (var i = 0; i < this._positions.length; i++) {\n        var _this$_positions$i = this._positions[i],\n            start = _this$_positions$i.start,\n            end = _this$_positions$i.end;\n\n        if (centerX + offset >= start && centerX - offset <= end) {\n          return i;\n        }\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"_getCenterX\",\n    value: function _getCenterX(event) {\n      var _this$props3 = this.props,\n          sliderWidth = _this$props3.sliderWidth,\n          itemWidth = _this$props3.itemWidth;\n      var containerSideMargin = (sliderWidth - itemWidth) / 2;\n      return event.nativeEvent.contentOffset.x + sliderWidth / 2 - containerSideMargin;\n    }\n  }, {\n    key: \"_onScroll\",\n    value: function _onScroll(event) {\n      var _this$props4 = this.props,\n          animationFunc = _this$props4.animationFunc,\n          animationOptions = _this$props4.animationOptions,\n          enableMomentum = _this$props4.enableMomentum;\n      var activeItem = this.state.activeItem;\n\n      var newActiveItem = this._getActiveItem(this._getCenterX(event));\n\n      if (enableMomentum) {\n        clearTimeout(this._snapNoMomentumTimeout);\n      }\n\n      if (activeItem !== newActiveItem) {\n        Animated[animationFunc](this.state.interpolators[activeItem], _objectSpread(_objectSpread({}, animationOptions), {}, {\n          toValue: 0\n        })).start();\n        this.setState({\n          activeItem: newActiveItem\n        });\n        Animated[animationFunc](this.state.interpolators[newActiveItem], _objectSpread(_objectSpread({}, animationOptions), {}, {\n          toValue: 1\n        })).start();\n      }\n    }\n  }, {\n    key: \"_onTouchStart\",\n    value: function _onTouchStart() {\n      if (this._autoplaying) {\n        this.stopAutoplay();\n      }\n    }\n  }, {\n    key: \"_onScrollBegin\",\n    value: function _onScrollBegin(event) {\n      this._scrollStartX = event.nativeEvent.contentOffset.x;\n      this._scrollStartActive = this.state.activeItem;\n      this._ignoreNextMomentum = false;\n    }\n  }, {\n    key: \"_onScrollEnd\",\n    value: function _onScrollEnd(event) {\n      var _this4 = this;\n\n      var _this$props5 = this.props,\n          autoplayDelay = _this$props5.autoplayDelay,\n          autoplay = _this$props5.autoplay;\n\n      if (this._ignoreNextMomentum) {\n        this._ignoreNextMomentum = false;\n        return;\n      }\n\n      this._scrollEndX = event.nativeEvent.contentOffset.x;\n      this._scrollEndActive = this.state.activeItem;\n      var deltaX = this._scrollEndX - this._scrollStartX;\n\n      if (this._snapEnabled) {\n        this._snapScroll(deltaX);\n      }\n\n      if (autoplay) {\n        clearTimeout(this._enableAutoplayTimeout);\n        this._enableAutoplayTimeout = setTimeout(function () {\n          _this4.startAutoplay(true);\n        }, autoplayDelay + 1000);\n      }\n    }\n  }, {\n    key: \"_onTouchRelease\",\n    value: function _onTouchRelease(event) {\n      var _this5 = this;\n\n      var enableMomentum = this.props.enableMomentum;\n\n      if (enableMomentum && Platform.OS === 'ios') {\n        this._snapNoMomentumTimeout = setTimeout(function () {\n          _this5._snapScroll(0);\n        }, 100);\n      }\n    }\n  }, {\n    key: \"_snapScroll\",\n    value: function _snapScroll(deltaX) {\n      var swipeThreshold = this.props.swipeThreshold;\n\n      if (!this._scrollEndActive && Platform.OS === 'ios') {\n        this._scrollEndActive = this._scrollStartActive;\n      }\n\n      if (this._scrollStartActive !== this._scrollEndActive) {\n        this.snapToItem(this._scrollEndActive);\n      } else {\n        if (deltaX > 0) {\n          if (deltaX > swipeThreshold) {\n            this.snapToItem(this._scrollStartActive + 1);\n          } else {\n            this.snapToItem(this._scrollEndActive);\n          }\n        } else if (deltaX < 0) {\n          if (deltaX < -swipeThreshold) {\n            this.snapToItem(this._scrollStartActive - 1);\n          } else {\n            this.snapToItem(this._scrollEndActive);\n          }\n        } else {\n          this.snapToItem(this._scrollEndActive);\n        }\n      }\n    }\n  }, {\n    key: \"items\",\n    get: function get() {\n      var _this6 = this;\n\n      var _this$props6 = this.props,\n          items = _this$props6.items,\n          renderItem = _this$props6.renderItem,\n          slideStyle = _this$props6.slideStyle,\n          inactiveSlideScale = _this$props6.inactiveSlideScale,\n          inactiveSlideOpacity = _this$props6.inactiveSlideOpacity;\n\n      if (!this.state.interpolators || !this.state.interpolators.length) {\n        return false;\n      }\n\n      return items.map(function (entry, index) {\n        var animatedValue = _this6.state.interpolators[index];\n        return React.createElement(Animated.View, {\n          key: \"carousel-item-\" + index,\n          style: [slideStyle, {\n            transform: [{\n              scale: animatedValue.interpolate({\n                inputRange: [0, 1],\n                outputRange: [inactiveSlideScale, 1]\n              })\n            }],\n            opacity: animatedValue.interpolate({\n              inputRange: [0, 1],\n              outputRange: [inactiveSlideOpacity, 1]\n            })\n          }],\n          __self: _this6,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 348,\n            columnNumber: 17\n          }\n        }, renderItem(entry, index));\n      });\n    }\n  }, {\n    key: \"currentIndex\",\n    get: function get() {\n      return this.state.activeItem;\n    }\n  }, {\n    key: \"startAutoplay\",\n    value: function startAutoplay() {\n      var _this7 = this;\n\n      var instantly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var _this$props7 = this.props,\n          autoplayInterval = _this$props7.autoplayInterval,\n          autoplayDelay = _this$props7.autoplayDelay;\n\n      if (this._autoplaying) {\n        return;\n      }\n\n      setTimeout(function () {\n        _this7._autoplaying = true;\n        _this7._autoplayInterval = setInterval(function () {\n          if (_this7._autoplaying) {\n            _this7.snapToItem(_this7._nextItem);\n          }\n        }, autoplayInterval);\n      }, instantly ? 0 : autoplayDelay);\n    }\n  }, {\n    key: \"stopAutoplay\",\n    value: function stopAutoplay() {\n      this._autoplaying = false;\n      clearInterval(this._autoplayInterval);\n    }\n  }, {\n    key: \"snapToItem\",\n    value: function snapToItem(index) {\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var fireCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var initial = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var itemsLength = this._positions.length;\n\n      if (index >= itemsLength) {\n        index = itemsLength - 1;\n        fireCallback = false;\n      } else if (index < 0) {\n        index = 0;\n        fireCallback = false;\n      }\n\n      var snapX = this._positions[index].start;\n\n      if (this.refs.scrollview) {\n        this.refs.scrollview.scrollTo({\n          x: snapX,\n          y: 0,\n          animated: animated\n        });\n        this.props.onSnapToItem && fireCallback && this.props.onSnapToItem(index, this.props.items[index]);\n\n        if (!initial && Platform.OS === 'ios') {\n          this._ignoreNextMomentum = true;\n        }\n      }\n    }\n  }, {\n    key: \"snapToNext\",\n    value: function snapToNext() {\n      var animated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var itemsLength = this._positions.length;\n      var newIndex = this.currentIndex + 1;\n\n      if (newIndex > itemsLength - 1) {\n        newIndex = 0;\n      }\n\n      this.snapToItem(newIndex, animated);\n    }\n  }, {\n    key: \"snapToPrev\",\n    value: function snapToPrev() {\n      var animated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var itemsLength = this._positions.length;\n      var newIndex = this.currentIndex - 1;\n\n      if (newIndex < 0) {\n        newIndex = itemsLength - 1;\n      }\n\n      this.snapToItem(newIndex, animated);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props8 = this.props,\n          sliderWidth = _this$props8.sliderWidth,\n          itemWidth = _this$props8.itemWidth,\n          containerCustomStyle = _this$props8.containerCustomStyle,\n          contentContainerCustomStyle = _this$props8.contentContainerCustomStyle,\n          enableMomentum = _this$props8.enableMomentum;\n      var containerSideMargin = (sliderWidth - itemWidth) / 2;\n      var style = [{\n        paddingHorizontal: Platform.OS === 'ios' ? containerSideMargin : 0\n      }, containerCustomStyle || {}];\n      var contentContainerStyle = [{\n        paddingHorizontal: Platform.OS === 'android' ? containerSideMargin : 0\n      }, contentContainerCustomStyle || {}];\n      return React.createElement(ScrollView, _extends({\n        decelerationRate: 0.9,\n        style: style,\n        contentContainerStyle: contentContainerStyle,\n        ref: 'scrollview',\n        horizontal: true,\n        onScrollBeginDrag: this._onScrollBegin,\n        onMomentumScrollEnd: enableMomentum ? this._onScrollEnd : undefined,\n        onScrollEndDrag: !enableMomentum ? this._onScrollEnd : undefined,\n        onResponderRelease: this._onTouchRelease,\n        onScroll: this._onScroll,\n        onTouchStart: this._onTouchStart,\n        scrollEventThrottle: 50\n      }, this.props, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 456,\n          columnNumber: 13\n        }\n      }), this.items);\n    }\n  }]);\n\n  return Carousel;\n}(Component);\n\nCarousel.propTypes = _objectSpread(_objectSpread({}, ScrollView.propTypes), {}, {\n  items: PropTypes.array.isRequired,\n  sliderWidth: PropTypes.number.isRequired,\n  itemWidth: PropTypes.number.isRequired,\n  renderItem: PropTypes.func.isRequired,\n  slideStyle: Animated.View.propTypes.style,\n  shouldOptimizeUpdates: PropTypes.bool,\n  containerCustomStyle: Animated.View.propTypes.style,\n  contentContainerCustomStyle: Animated.View.propTypes.style,\n  swipeThreshold: PropTypes.number,\n  animationFunc: PropTypes.string,\n  animationOptions: PropTypes.object,\n  inactiveSlideScale: PropTypes.number,\n  inactiveSlideOpacity: PropTypes.number,\n  firstItem: PropTypes.number,\n  autoplay: PropTypes.bool,\n  autoplayInterval: PropTypes.number,\n  autoplayDelay: PropTypes.number,\n  enableSnap: PropTypes.bool,\n  enableMomentum: PropTypes.bool,\n  snapOnAndroid: PropTypes.bool,\n  onSnapToItem: PropTypes.func\n});\nCarousel.defaultProps = {\n  shouldOptimizeUpdates: true,\n  autoplay: false,\n  autoplayInterval: 3000,\n  autoplayDelay: 5000,\n  firstItem: 0,\n  enableSnap: true,\n  enableMomentum: true,\n  snapOnAndroid: false,\n  swipeThreshold: 20,\n  animationFunc: 'timing',\n  animationOptions: {\n    easing: Easing.elastic(1)\n  },\n  slideStyle: {},\n  containerCustomStyle: null,\n  contentContainerCustomStyle: null,\n  inactiveSlideScale: 0.9,\n  inactiveSlideOpacity: 1\n};\nexport { Carousel as default };","map":{"version":3,"sources":["/Users/sumedhreddy/Documents/stealth/stealth-startup/node_modules/react-native-snap-carousel/index.js"],"names":["React","Component","PropTypes","shallowCompare","Carousel","props","state","activeItem","firstItem","_positions","_calcCardPositions","_onTouchStart","bind","_onScroll","_onScrollEnd","_snapEnabled","_onScrollBegin","_initInterpolators","_onTouchRelease","_ignoreNextMomentum","autoplay","setTimeout","snapToItem","startAutoplay","nextProps","nextState","shouldOptimizeUpdates","items","length","setState","stopAutoplay","enableSnap","snapOnAndroid","Platform","OS","itemWidth","forEach","item","index","start","end","interpolators","push","Animated","Value","centerX","offset","i","event","sliderWidth","containerSideMargin","nativeEvent","contentOffset","x","animationFunc","animationOptions","enableMomentum","newActiveItem","_getActiveItem","_getCenterX","clearTimeout","_snapNoMomentumTimeout","toValue","_autoplaying","_scrollStartX","_scrollStartActive","autoplayDelay","_scrollEndX","_scrollEndActive","deltaX","_snapScroll","_enableAutoplayTimeout","swipeThreshold","renderItem","slideStyle","inactiveSlideScale","inactiveSlideOpacity","map","entry","animatedValue","transform","scale","interpolate","inputRange","outputRange","opacity","instantly","autoplayInterval","_autoplayInterval","setInterval","_nextItem","clearInterval","animated","fireCallback","initial","itemsLength","snapX","refs","scrollview","scrollTo","y","onSnapToItem","newIndex","currentIndex","containerCustomStyle","contentContainerCustomStyle","style","paddingHorizontal","contentContainerStyle","undefined","propTypes","ScrollView","array","isRequired","number","func","View","bool","string","object","defaultProps","easing","Easing","elastic"],"mappings":"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","sourcesContent":["import React, { Component, PropTypes } from 'react';\nimport { ScrollView, Animated, Platform, Easing } from 'react-native';\nimport shallowCompare from 'react-addons-shallow-compare';\n\nexport default class Carousel extends Component {\n\n    static propTypes = {\n        ...ScrollView.propTypes,\n        /**\n         * Supply items to loop on\n         */\n        items: PropTypes.array.isRequired,\n        /**\n         * Width in pixels of your slider according\n         * to your styles\n         */\n        sliderWidth: PropTypes.number.isRequired,\n        /**\n         * Width in pixels of your elements\n         */\n        itemWidth: PropTypes.number.isRequired,\n        /**\n         * Function returning a react element. The entry\n         * data is the 1st parameter, its index is the 2nd\n         */\n        renderItem: PropTypes.func.isRequired,\n        /**\n         * Style of each item's container\n         */\n        slideStyle: Animated.View.propTypes.style,\n        /**\n         * whether to implement a `shouldComponentUpdate`\n         * strategy to minimize updates\n         */\n        shouldOptimizeUpdates: PropTypes.bool,\n        /**\n        * Global wrapper's style\n        */\n        containerCustomStyle: Animated.View.propTypes.style,\n        /**\n        * Content container's style\n        */\n        contentContainerCustomStyle: Animated.View.propTypes.style,\n        /**\n         * Delta x when swiping to trigger the snap\n         */\n        swipeThreshold: PropTypes.number,\n        /**\n         * Animated animation to use. Provide the name\n         * of the method, defaults to timing\n         */\n        animationFunc: PropTypes.string,\n        /**\n         * Animation options to be merged with the\n         * default ones. Can be used w/ animationFunc\n         */\n        animationOptions: PropTypes.object,\n        /**\n         * Scale factor of the inactive slides\n         */\n        inactiveSlideScale: PropTypes.number,\n        /**\n         * Opacity value of the inactive slides\n         */\n        inactiveSlideOpacity: PropTypes.number,\n        /**\n         * Index of the first item to display\n         */\n        firstItem: PropTypes.number,\n        /**\n         * Trigger autoplay\n         */\n        autoplay: PropTypes.bool,\n        /**\n         * Delay until navigating to the next item\n         */\n        autoplayInterval: PropTypes.number,\n        /**\n         * Delay before enabling autoplay on startup and\n         * after releasing the touch\n         */\n        autoplayDelay: PropTypes.number,\n        /**\n         * If enabled, releasing the touch will scroll\n         * to the center of the nearest/active item\n         */\n        enableSnap: PropTypes.bool,\n        /**\n         * If enabled, snapping will be triggered once\n         * the ScrollView stops moving, not when the\n         * user releases his finger\n        */\n        enableMomentum: PropTypes.bool,\n        /**\n         * Snapping on android is kinda choppy, especially\n         * when swiping quickly so you can disable it\n         */\n        snapOnAndroid: PropTypes.bool,\n        /**\n         * Fired when snapping to an item\n         */\n        onSnapToItem: PropTypes.func\n    };\n\n    static defaultProps = {\n        shouldOptimizeUpdates: true,\n        autoplay: false,\n        autoplayInterval: 3000,\n        autoplayDelay: 5000,\n        firstItem: 0,\n        enableSnap: true,\n        enableMomentum: true,\n        snapOnAndroid: false,\n        swipeThreshold: 20,\n        animationFunc: 'timing',\n        animationOptions: {\n            easing: Easing.elastic(1)\n        },\n        slideStyle: {},\n        containerCustomStyle: null,\n        contentContainerCustomStyle: null,\n        inactiveSlideScale: 0.9,\n        inactiveSlideOpacity: 1\n    }\n\n    constructor (props) {\n        super(props);\n        this.state = {\n            activeItem: props.firstItem\n        };\n        this._positions = [];\n        this._calcCardPositions(props);\n        this._onTouchStart = this._onTouchStart.bind(this);\n        this._onScroll = this._onScroll.bind(this);\n        this._onScrollEnd = this._snapEnabled ? this._onScrollEnd.bind(this) : false;\n        this._onScrollBegin = this._snapEnabled ? this._onScrollBegin.bind(this) : false;\n        this._initInterpolators = this._initInterpolators.bind(this);\n        this._onTouchRelease = this._onTouchRelease.bind(this);\n        // This bool aims at fixing an iOS bug due to scrolTo that triggers onMomentumScrollEnd.\n        // onMomentumScrollEnd fires this._snapScroll, thus creating an infinite loop.\n        this._ignoreNextMomentum = false;\n    }\n\n    componentDidMount () {\n        const { firstItem, autoplay } = this.props;\n\n        this._initInterpolators(this.props);\n        setTimeout(() => {\n            this.snapToItem(firstItem, false, false, true);\n        }, 0);\n        if (autoplay) {\n            this.startAutoplay();\n        }\n    }\n\n    shouldComponentUpdate (nextProps, nextState) {\n        if (this.props.shouldOptimizeUpdates === false) {\n            return true;\n        } else {\n            return shallowCompare(this, nextProps, nextState);\n        }\n    }\n\n    componentWillReceiveProps (nextProps) {\n        const { items, firstItem } = nextProps;\n\n        if (items.length !== this.props.items.length) {\n            this._positions = [];\n            this._calcCardPositions(nextProps);\n            this._initInterpolators(nextProps);\n            this.setState({ activeItem: firstItem });\n        }\n    }\n\n    componentWillUnmount () {\n        this.stopAutoplay();\n    }\n\n    get _snapEnabled () {\n        const { enableSnap, snapOnAndroid } = this.props;\n\n        return enableSnap && (Platform.OS === 'ios' || snapOnAndroid);\n    }\n\n    get _nextItem () {\n        const { activeItem } = this.state;\n\n        return this._positions[activeItem + 1] ? activeItem + 1 : 0;\n    }\n\n    _calcCardPositions (props = this.props) {\n        const { items, itemWidth } = props;\n\n        items.forEach((item, index) => {\n            this._positions[index] = {\n                start: index * itemWidth\n            };\n            this._positions[index].end = this._positions[index].start + itemWidth;\n        });\n    }\n\n    _initInterpolators (props = this.props) {\n        const { items, firstItem } = props;\n        let interpolators = [];\n\n        items.forEach((item, index) => {\n            interpolators.push(new Animated.Value(index === firstItem ? 1 : 0));\n        });\n        this.setState({ interpolators });\n    }\n\n    _getActiveItem (centerX, offset = 25) {\n        for (let i = 0; i < this._positions.length; i++) {\n            const { start, end } = this._positions[i];\n            if (centerX + offset >= start && centerX - offset <= end) {\n                return i;\n            }\n        }\n        return 0;\n    }\n\n    _getCenterX (event) {\n        const { sliderWidth, itemWidth } = this.props;\n        const containerSideMargin = (sliderWidth - itemWidth) / 2;\n\n        return event.nativeEvent.contentOffset.x + sliderWidth / 2 - containerSideMargin;\n    }\n\n    _onScroll (event) {\n        const { animationFunc, animationOptions, enableMomentum } = this.props;\n        const { activeItem } = this.state;\n        const newActiveItem = this._getActiveItem(this._getCenterX(event));\n\n        if (enableMomentum) {\n            clearTimeout(this._snapNoMomentumTimeout);\n        }\n\n        if (activeItem !== newActiveItem) {\n            Animated[animationFunc](\n                this.state.interpolators[activeItem],\n                { ...animationOptions, toValue: 0 }\n            ).start();\n            this.setState({ activeItem: newActiveItem });\n            Animated[animationFunc](\n                this.state.interpolators[newActiveItem],\n                { ...animationOptions, toValue: 1 }\n            ).start();\n        }\n    }\n\n    _onTouchStart () {\n        if (this._autoplaying) {\n            this.stopAutoplay();\n        }\n    }\n\n    _onScrollBegin (event) {\n        this._scrollStartX = event.nativeEvent.contentOffset.x;\n        this._scrollStartActive = this.state.activeItem;\n        this._ignoreNextMomentum = false;\n    }\n\n    _onScrollEnd (event) {\n        const { autoplayDelay, autoplay } = this.props;\n\n        if (this._ignoreNextMomentum) {\n            // iOS fix\n            this._ignoreNextMomentum = false;\n            return;\n        }\n        this._scrollEndX = event.nativeEvent.contentOffset.x;\n        this._scrollEndActive = this.state.activeItem;\n\n        const deltaX = this._scrollEndX - this._scrollStartX;\n\n        if (this._snapEnabled) {\n            this._snapScroll(deltaX);\n        }\n\n        if (autoplay) {\n            // Restart autoplay after a little while\n            // This could be done when releasing touch\n            // but the event is buggy on Android...\n            clearTimeout(this._enableAutoplayTimeout);\n            this._enableAutoplayTimeout =\n                setTimeout(() => {\n                    this.startAutoplay(true);\n                }, autoplayDelay + 1000);\n        }\n    }\n\n    // Due to a bug, this event is only fired on iOS\n    // https://github.com/facebook/react-native/issues/6791\n    // it's fine since we're only fixing an iOS bug in it, so ...\n    _onTouchRelease (event) {\n        const { enableMomentum } = this.props;\n\n        if (enableMomentum && Platform.OS === 'ios') {\n            this._snapNoMomentumTimeout =\n                setTimeout(() => {\n                    this._snapScroll(0);\n                }, 100);\n        }\n    }\n\n    _snapScroll (deltaX) {\n        const { swipeThreshold } = this.props;\n\n        // When using momentum and releasing the touch with\n        // no velocity, scrollEndActive will be undefined (iOS)\n        if (!this._scrollEndActive && Platform.OS === 'ios') {\n            this._scrollEndActive = this._scrollStartActive;\n        }\n\n        if (this._scrollStartActive !== this._scrollEndActive) {\n            // Snap to the new active item\n            this.snapToItem(this._scrollEndActive);\n        } else {\n            // Snap depending on delta\n            if (deltaX > 0) {\n                if (deltaX > swipeThreshold) {\n                    this.snapToItem(this._scrollStartActive + 1);\n                } else {\n                    this.snapToItem(this._scrollEndActive);\n                }\n            } else if (deltaX < 0) {\n                if (deltaX < -swipeThreshold) {\n                    this.snapToItem(this._scrollStartActive - 1);\n                } else {\n                    this.snapToItem(this._scrollEndActive);\n                }\n            } else {\n                // Snap to current\n                this.snapToItem(this._scrollEndActive);\n            }\n        }\n    }\n\n    get items () {\n        const { items, renderItem, slideStyle, inactiveSlideScale, inactiveSlideOpacity } = this.props;\n        if (!this.state.interpolators || !this.state.interpolators.length) {\n            return false;\n        }\n\n        return items.map((entry, index) => {\n            const animatedValue = this.state.interpolators[index];\n            return (\n                <Animated.View\n                  key={`carousel-item-${index}`}\n                  style={[\n                      slideStyle,\n                      {transform: [{\n                          scale: animatedValue.interpolate({\n                              inputRange: [0, 1],\n                              outputRange: [inactiveSlideScale, 1]\n                          })\n                      }],\n                          opacity: animatedValue.interpolate({\n                              inputRange: [0, 1],\n                              outputRange: [inactiveSlideOpacity, 1]\n                          })\n                      }\n                  ]}>\n                    { renderItem(entry, index) }\n                </Animated.View>\n            );\n        });\n    }\n\n    get currentIndex () {\n        return this.state.activeItem;\n    }\n\n    startAutoplay (instantly = false) {\n        const { autoplayInterval, autoplayDelay } = this.props;\n\n        if (this._autoplaying) {\n            return;\n        }\n\n        setTimeout(() => {\n            this._autoplaying = true;\n            this._autoplayInterval =\n                setInterval(() => {\n                    if (this._autoplaying) {\n                        this.snapToItem(this._nextItem);\n                    }\n                }, autoplayInterval);\n        }, instantly ? 0 : autoplayDelay);\n    }\n\n    stopAutoplay () {\n        this._autoplaying = false;\n        clearInterval(this._autoplayInterval);\n    }\n\n    snapToItem (index, animated = true, fireCallback = true, initial = false) {\n        const itemsLength = this._positions.length;\n\n        if (index >= itemsLength) {\n            index = itemsLength - 1;\n            fireCallback = false;\n        } else if (index < 0) {\n            index = 0;\n            fireCallback = false;\n        }\n\n        const snapX = this._positions[index].start;\n\n        // Make sure the component hasn't been unmounted\n        if (this.refs.scrollview) {\n            this.refs.scrollview.scrollTo({x: snapX, y: 0, animated});\n            this.props.onSnapToItem && fireCallback && this.props.onSnapToItem(index, this.props.items[index]);\n\n            // iOS fix, check the note in the constructor\n            if (!initial && Platform.OS === 'ios') {\n                this._ignoreNextMomentum = true;\n            }\n        }\n    }\n\n    snapToNext (animated = true) {\n        const itemsLength = this._positions.length;\n\n        let newIndex = this.currentIndex + 1;\n        if (newIndex > itemsLength - 1) {\n            newIndex = 0;\n        }\n        this.snapToItem(newIndex, animated);\n    }\n\n    snapToPrev (animated = true) {\n        const itemsLength = this._positions.length;\n\n        let newIndex = this.currentIndex - 1;\n        if (newIndex < 0) {\n            newIndex = itemsLength - 1;\n        }\n        this.snapToItem(newIndex, animated);\n    }\n\n    render () {\n        const { sliderWidth, itemWidth, containerCustomStyle, contentContainerCustomStyle, enableMomentum } = this.props;\n\n        const containerSideMargin = (sliderWidth - itemWidth) / 2;\n        const style = [\n            { paddingHorizontal: Platform.OS === 'ios' ? containerSideMargin : 0 },\n            containerCustomStyle || {}\n        ];\n        const contentContainerStyle = [\n            { paddingHorizontal: Platform.OS === 'android' ? containerSideMargin : 0 },\n            contentContainerCustomStyle || {}\n        ];\n\n        return (\n            <ScrollView\n              decelerationRate={0.9}\n              style={style}\n              contentContainerStyle={contentContainerStyle}\n              ref={'scrollview'}\n              horizontal={true}\n              onScrollBeginDrag={this._onScrollBegin}\n              onMomentumScrollEnd={enableMomentum ? this._onScrollEnd : undefined}\n              onScrollEndDrag={!enableMomentum ? this._onScrollEnd : undefined}\n              onResponderRelease={this._onTouchRelease}\n              onScroll={this._onScroll}\n              onTouchStart={this._onTouchStart}\n              scrollEventThrottle={50}\n              {...this.props}\n              >\n                { this.items }\n            </ScrollView>\n        );\n    }\n}\n"]},"metadata":{},"sourceType":"module"}